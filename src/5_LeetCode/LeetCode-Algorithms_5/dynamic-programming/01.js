/**
 * 假设你正在爬楼梯。需要 n 步你才能到达楼顶。
 * 
 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 * 
 * 注意：给定 n 是一个正整数。
 * 
 * 示例 1：
 * 
 * 输入： 2
 * 输出： 2
 * 解释： 有两种方法可以爬到楼顶。
 * 1.  1 步 + 1 步
 * 2.  2 步
 * 示例 2：
 * 
 * 输入： 3
 * 输出： 3
 * 解释： 有三种方法可以爬到楼顶。
 * 1.  1 步 + 1 步 + 1 步
 * 2.  1 步 + 2 步
 * 3.  2 步 + 1 步
 */

 /**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {//使用动态规划， 斐波那契数列
    let one = 1, two = 2
    if(n === 1) return one
    if(n === two) return two
    let temp = 0
    for(let i = 2; i < n; i++){
        temp = one + two
        one = two
        two = temp
    }
    return temp
    
};

climbStairs(10)
/**
 * 如果是第一次看这个代码有点不明白为什么会这样写。 在这里做一个简单的分析
 * 
 * 首先说个名词： 动态规划
 * 该题就是使用动态规划做的， 而动态规划的思想是怎样的呢？
 * 
 * 动态规划， 就是知道前一个状态， 通过状态的转移， 到下一个状态。直到终止条件， 得到结果。 这样说肯定有些抽象， 新手肯定会不理解。
 * 举个例子来说， 
 * 就本体而言， 很多人一开始就会想用排列的方式， 来暴力破解。 这样做肯定可以但是不够优雅。
 * 请看动态规划， 是如何优雅的思考问题的：
 * 第一， 假设你最后一下需要到第10个阶梯。你能怎么到呢？ 只有两种方法， 那就是从第8阶梯， 一下走2个阶梯到达。 还有就是从第9阶梯， 一下走一个阶梯， 到达。
 * 假设从1 到 8 的走法为 F(8), 从1 到9的走法为F(9)
 * 那么从1 到10 的走法为F(10) =  F(8) + F(9)
 * 这里有一个状态 F(8) 和 F(9) 通过F(8) + F（9） 转移到 F(10)
 * 
 * 但是由于我们不知道F(9) 和 F(9)的具体值， 也需要这样得到。 即： F(9) = F(8) + F(7) ; F(8) = F(7) + F(6)
 * 这样一直到 F(0) 和 F(1) 。 
 * 由于， F(2) 和 F(1) 我们可以很容易得到， 所以， 就可以递归的运算得到 F(10).
 *  
 * 这里我没有采用递归的方式， 因为， 递归会很多的重复运算， 比如， 在计算F(10)时， 会计算 F(8), 在计算F(9)时， 也会计算F(8)。 当然也可以使用记忆的方式， 得到已经计算过的结果
 * 避免重复计算。 
 * 
 * 这里我使用是的for循环， 自底向上的运算。也就是从F(1) + F(2) + F(3)这样一直与通过上一个值， 跑一遍就好。 
 * 
 * 在做动态规划的题时：
 * 第一个是，其实条件， 
 * 第二是，转移方程
 * 第三是， 终止条件
 * 
 * 通过上面的分析。 可以知道怎么解题。
 * 
 * 解题 可以使用递归和for循环。
 * 这里我建议， 使用自顶向下的递归方式分析问题， 采用自底向上的for循环的方式写代码。
 * 
 * 
 *  
 *   
 *
 * 
 * 
 *
 */
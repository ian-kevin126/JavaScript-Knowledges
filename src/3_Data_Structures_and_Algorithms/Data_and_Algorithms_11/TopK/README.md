# 在数组中找到第k大的元素
------------

### Quick Select 
 
#### 时间复杂度 
完整的平均时间复杂度分析非常复杂，在这里不再赘述。有兴趣的可以看算导。 

#####理想状况

假如每次都平分，这样时间复杂度展开是 O(n + n/2 + n/4 + ... .+1) = O(2n) = O(n)。

因为算法是，挑选一个 pivot 之后，O(n) 时间进行 partition，然后判断一下第 k 大在左边还是在右边。然后继续往下进行，那么理想情况下，无论去左边还是去右边，规模都从 n 变成了 n/2。

T(n) = O(n) + T(n/2)

T(n/2) = O(n/2) + T(n/4)

...

T(2) = O(1) + T(1)

T(1) = O(1)

所以 T(n) = T(n/2) + O(n) = O(n).

##### 不理想情况
运气很不好的话，每次的 pivot 都取到了最大或者最小的值，那么复杂度展开是 O(n + n-1 + n-2 + n-3 ... + 1) = O(n^2)。

那么我们应该怎么衡量这个算法的时间复杂度呢？

类似快速排序我们认为是 O(nlogn) 的，因为我们算的是平均时间复杂度，也就是平摊一下各种情况的概率和时间复杂度。

因为并不一定每次都运气那么不好，比如你用随机的方式挑选 pivot 的话，这样我们认为 quick select 的时间复杂度均摊是 O(n) 的。


#### 空间复杂度 

算法没有使用额外空间，所以算法的空间复杂度为 O(1)。


top k（找最大的k个数）
------------
堆

二叉堆是完全二元树或者是近似完全二元树，按照数据的排列方式可以分为两种：最大堆和最小堆。

最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。

优先队列

# 题目

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
> 你不需要考虑数组中超出新长度后面的元素。	

示例 2:

> 给定 nums = [0,0,1,1,1,2,2,3,3,4],
>
> 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>
> 你不需要考虑数组中超出新长度后面的元素。

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```java
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 解法

```javascript
 const removeDuplicates = nums => {
  let length = 1;
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] === nums[i - 1]) {
    } else {
      nums[length] = nums[i];
      length++;
    }
  }
  return length;
};

let arr = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4];

console.log(removeDuplicates(arr));

console.log(arr);
```

# 分析

由于此题只需要**修改**数组前几位元素，去除重复的元素，并修改为非重复的元素，所以可以使用**取巧**的方法，即

`不需要关心数组后面的元素，将前面的元素修改，并返回非重复元素的长度即可`

所以我们可以用过 length 变量记录非重复元素的数量，并且也可以通过它来定位下标来修改元素

当遇到非重复元素时 length ++，然后将当前的非重复元素赋值给当前数组 length 下标的元素（必须是 length 下标，而不是 i -1 下标，因为可能存在多个相同元素，此时需要被修改的元素就不是 i-1 的位置了）

